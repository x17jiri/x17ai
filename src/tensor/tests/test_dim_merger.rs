// Copyright 2025 Jiri Bobek. All rights reserved.
// License: GPL 3.0 or later. See LICENSE.txt for details.

use super::super::dim_merger::*;

use crate::data2d;
use crate::nn::EvalContext;
use crate::nn::layers::Layer;
use crate::tensor::device::cpu::CPUDevice;
use crate::tensor::dim_vec::SizeAndStride;
use crate::tensor::math::Savable;
use crate::tensor::{self, Tensor};

// Note: The expected tensors were generated by:
//
//    python gen_test_data.py rms_norm

#[test]
fn test_dim_merger() {
	// This was a real use case that failed in the past.

	let d_lin = [
		SizeAndStride { size: 4, stride: 14 }, //
		SizeAndStride { size: 1, stride: 7 },
		SizeAndStride { size: 7, stride: 1 },
	];
	let d_gate = [
		SizeAndStride { size: 4, stride: 14 }, //
		SizeAndStride { size: 1, stride: 7 },
		SizeAndStride { size: 7, stride: 1 },
	];
	let lin = [
		// SizeAndStride { size: 1, stride: 0 },
		SizeAndStride { size: 4, stride: 14 },
		SizeAndStride { size: 7, stride: 1 },
	];
	let gate = [
		// SizeAndStride { size: 1, stride: 0 },
		SizeAndStride { size: 4, stride: 14 },
		SizeAndStride { size: 7, stride: 1 },
	];
	let out = [
		// SizeAndStride { size: 1, stride: 0 },
		SizeAndStride { size: 4, stride: 7 },
		SizeAndStride { size: 7, stride: 1 },
	];

	let merger = DimMerger::new([&d_lin, &d_gate, &lin, &gate, &out]);
	let dims = merger.dims_increasing();

	let expected_dims = [
		MergedDim { size: 7, strides: [1, 1, 1, 1, 1] },
		MergedDim { size: 4, strides: [0, 0, 14, 14, 7] },
		MergedDim { size: 4, strides: [14, 14, 0, 0, 0] },
	];

	assert_eq!(dims.len(), expected_dims.len());
	for (i, dim) in dims.iter().enumerate() {
		assert_eq!(dim.size, expected_dims[i].size);
		assert_eq!(dim.strides, expected_dims[i].strides);
	}
}
