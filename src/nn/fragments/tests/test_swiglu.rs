//------------------------------------------------------------------------------
//
// Copyright 2025 Jiri Bobek. All rights reserved.
// License: GPL 3.0 or later. See LICENSE.txt for details.
//
//------------------------------------------------------------------------------

use super::super::swiglu::*;

use crate::autograd::{AutogradTensor, GradientCapture};
use crate::nn::fragments::UnaryFragment;
use crate::tensor::device::cpu::CPUDevice;
use crate::tensor::math::approx_eq;
use crate::tensor::{HasDType, Tensor, TensorOpError};
use crate::{ErrPack, autograd};

// Note: The expected tensors were generated by gen_test_data.py

#[allow(clippy::panic_in_result_fn)]
#[allow(clippy::approx_constant)]
#[allow(clippy::unwrap_used)]
#[test]
fn test_swiglu() -> Result<(), ErrPack<TensorOpError>> {
	let internal_dtype = f32::dtype;

	let swiglu = SwiGLU::new(internal_dtype);
	let dev = CPUDevice::new();

	#[rustfmt::skip] let inp = Tensor::literal_factory::<f32>(dev.clone()).new_3d(&[
		[
			[-0.8714,  0.0940, -1.8542,  0.7304, -0.2773, -0.7002, -0.6732],
			[-0.3639,  0.3168, -0.1291,  0.0461,  1.1104,  1.1302,  0.9531],
		], [
			[-0.4135,  0.8453, -1.5096, -0.6099,  0.3261,  0.0221,  0.2651],
			[-0.6350,  1.2983, -0.3186,  1.1820,  0.8960,  0.3618,  0.7403],
		], [
			[ 1.4432,  3.0449,  1.6251, -0.9864,  0.5130,  0.7087,  0.0929],
			[-1.0867, -0.9725,  0.6218,  0.0897, -0.6929,  0.6524,  2.0153],
		], [
			[-1.2271, -1.5085,  0.6593,  1.9288, -1.3475, -2.3681,  1.6462],
			[ 1.1650, -0.5926,  0.2599,  1.1419, -1.1015,  0.7637,  1.9136],
		],
	])?;

	#[rustfmt::skip] let expected_out = Tensor::literal_factory::<f32>(dev.clone()).new_2d(&[
		[ 0.1300,  0.0172,  0.1120,  0.0172, -0.2316, -0.5982, -0.4631],
		[ 0.0909,  0.8621,  0.2025, -0.5517,  0.2075,  0.0047,  0.1329],
		[-0.3956, -0.8125,  0.6575, -0.0462, -0.1185,  0.3040,  0.1652],
		[-1.0897,  0.3183,  0.0967,  1.6696,  0.3703, -1.2337,  2.7451],
	])?;

	let d_inp_capture = GradientCapture::new();
	let d_inp = d_inp_capture.storage();
	let out = swiglu.forward(AutogradTensor::new(inp, Some(d_inp_capture)))?;
	let (out, backward_fn) = out.into_parts();

	println!("out = {}", &out);
	println!("expected_out = {}", &expected_out);

	assert!(approx_eq(&out, &expected_out, 1e-4)?);

	#[rustfmt::skip] let d_out = Tensor::literal_factory::<f32>(dev.clone()).new_2d(&[
		[-0.8866,  0.5923,  1.6628, -0.0801, -0.8071, -0.4731, -0.5233],
		[ 1.1934, -0.0170,  0.1537,  0.4730, -0.5441,  0.9822,  0.1070],
		[-1.4121, -0.9289,  0.4226,  0.2391, -1.1131, -0.2210, -0.7231],
		[ 0.4270,  1.0933,  0.2516, -0.1986,  0.7602, -1.7255, -0.9384],
	])?;

	#[rustfmt::skip] let expected_d_inp = Tensor::literal_factory::<f32>(dev).new_3d(&[
		[
		[ 1.3228e-01,  1.0856e-01, -1.0041e-01, -1.8889e-03, -6.7413e-01, -4.0416e-01, -3.5997e-01],
		[ 2.4876e-01,  3.6512e-02, -1.3431e+00, -3.0601e-02,  2.1467e-01,  3.1948e-01,  3.2169e-01],
		], [
		[-2.6249e-01, -1.7338e-02, -2.0617e-02,  4.2787e-01, -3.4620e-01,  2.0948e-01,  5.3631e-02],
		[-9.9984e-02, -1.4431e-02, -7.9667e-02, -2.8202e-01, -1.5872e-01,  1.4696e-02,  2.3797e-02],
		], [
		[ 3.8707e-01,  2.4786e-01,  1.7097e-01,  1.1204e-02,  2.5713e-01, -9.4806e-02, -1.2859e+00],
		[-9.6338e-02, -2.2842e-01,  5.4390e-01, -1.2849e-01, -1.0244e-01, -1.2600e-01, -7.3325e-02],
		], [
		[ 3.7918e-01, -2.3067e-01,  3.6920e-02, -1.7191e-01, -2.0889e-01, -8.9892e-01, -1.5648e+00],
		[-5.1002e-01, -3.6311e-01,  1.0426e-01, -3.7060e-01, -4.4279e-02,  3.4640e+00, -1.6774e+00],
		],
	])?;

	autograd::run(backward_fn, d_out)?;
	let d_inp = d_inp.borrow_mut().take().unwrap();

	println!("d_inp = {}", &d_inp);
	println!("expected_d_inp = {}", &expected_d_inp);

	assert!(approx_eq(&d_inp, &expected_d_inp, 1e-4)?);
	Ok(())
}
