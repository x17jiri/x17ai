//------------------------------------------------------------------------------
//
// Copyright 2025 Jiri Bobek. All rights reserved.
// License: GPL 3.0 or later. See LICENSE.txt for details.
//
//------------------------------------------------------------------------------

use super::super::rms_norm::*;

use crate::ErrPack;
use crate::autograd::{self, AutogradTensor, GradientCapture};
use crate::nn::fragments::UnaryFragment;
use crate::nn::fragments::skip_connection::SkipConnection;
use crate::tensor::device::cpu::CPUDevice;
use crate::tensor::math::approx_eq;
use crate::tensor::{HasDType, Tensor, TensorOpError};

// Note: The expected tensors were generated by gen_test_data.py

#[allow(clippy::panic_in_result_fn)]
#[allow(clippy::unwrap_used)]
#[test]
fn test_skip_con() -> Result<(), ErrPack<TensorOpError>> {
	let internal_dtype = f32::dtype;

	let skip_con =
		SkipConnection::new(RMSNorm::new(1e-5, internal_dtype, RMSNormGradMode::Precise));
	let dev = CPUDevice::new();

	#[rustfmt::skip] let inp = Tensor::literal_factory::<f32>(dev.clone()).new_2d(&[
		[-1.2719, -0.6884, -0.6477, -1.3343, -1.7648],
		[-1.9440,  0.9989,  2.8260, -0.3503, -0.5406],
		[ 0.1619, -0.9744, -0.6539,  1.9764,  0.7423],
		[ 0.0689,  1.1983,  0.0077, -0.6580, -0.4917],
	])?;

	#[rustfmt::skip] let expected_out = Tensor::literal_factory::<f32>(dev.clone()).new_2d(&[
		[-2.3170, -1.2540, -1.1799, -2.4306, -3.2149],
		[-3.1414,  1.6142,  4.5667, -0.5661, -0.8736],
		[ 0.3114, -1.8744, -1.2579,  3.8019,  1.4279],
		[ 0.1748,  3.0405,  0.0195, -1.6696, -1.2476],
	])?;

	let d_inp_capture = GradientCapture::new();
	let d_inp = d_inp_capture.storage();
	let out = skip_con.forward(AutogradTensor::new(inp, Some(d_inp_capture)))?;
	let (out, backward_fn) = out.into_parts();

	println!("out = {}", &out);
	println!("expected_out = {}", &expected_out);

	assert!(approx_eq(&out, &expected_out, 1e-4)?);

	#[rustfmt::skip] let d_out = Tensor::literal_factory::<f32>(dev.clone()).new_2d(&[
		[ 0.1000,  0.2000, -0.3000, -0.1000,  0.7000],
		[ 0.0500, -0.1500,  0.1000,  0.0000,  0.6500],
		[-0.2000,  0.1000,  0.0500,  0.0500,  0.3331],
		[ 0.0000,  0.1000, -0.0500, -0.0500, -0.1442],
	])?;

	#[rustfmt::skip] let expected_d_inp = Tensor::literal_factory::<f32>(dev).new_2d(&[
		[ 0.0167,  0.2748, -0.6308, -0.3557,  1.0456],
		[ 0.0521, -0.2276,  0.2033, -0.0052,  1.0424],
		[-0.3894,  0.2206,  0.1151,  0.0390,  0.6193],
		[-0.0112,  0.0593, -0.1281, -0.0201, -0.2861],
	])?;

	autograd::run(backward_fn, d_out)?;
	let d_inp = d_inp.borrow_mut().take().unwrap();

	println!("d_inp = {}", &d_inp);
	println!("expected_d_inp = {}", &expected_d_inp);

	assert!(approx_eq(&d_inp, &expected_d_inp, 1e-4)?);
	Ok(())
}
